---
id: 0002
title: Create Implementation Plan for Phase 1 Foundation Setup
stage: plan
date: 2026-01-01
surface: agent
model: gemini-1.5-flash
feature: P2-1-foundation-setup
branch: P2-1-foundation-setup
user: CLI_USER
command: /sp.plan Create Implementation Plan for Phase 1: Project Foundation Setup ## CONTEXT: You are an expert technical project planner. I need you to create a detailed implementation plan for Phase 1 of our ADD_TaskFlow-App project based on: 1. Constitution File: Contains all project standards and 4-phase structure 2. Phase 1 Specification: Detailed requirements at specs/00-1 Project Foundation Setup/spec.md ## INPUT DOCUMENTS: ### Constitution Highlights: - Project: ADD_TaskFlow-App (Modern Todo Web Application) - Phases: 4 total (1: Foundation, 2: Auth, 3: Tasks, 4: UI Integration) - Tech Stack: Next.js 16, FastAPI, SQLModel, Neon PostgreSQL, Tailwind CSS, Framer Motion - Code Standards: TypeScript strict, Python 3.12+, full type hints, SQLModel only - Security: JWT tokens, user data isolation, environment variables for secrets - Design System: Colors (blue-purple gradient), Inter font, 4px spacing base, Framer Motion animations - Testing: Frontend 80% coverage, Backend 90% coverage ### Phase 1 Specification Summary: - Goal: Establish complete development foundation - Scope: Monorepo structure, Next.js 16 + FastAPI setup, Design System, Development environment - Requirements: - Monorepo with frontend/, backend/, specs/, docs/ - Next.js 16 with TypeScript, Tailwind CSS, Framer Motion - FastAPI with SQLModel, Neon PostgreSQL connection - Design System: Colors, Typography, Spacing, 6 UI components - Environment setup: Git, env vars, scripts, documentation - Acceptance Criteria: 21 SMART criteria across Frontend, Backend, Development, Design System - Timeline: 3-5 days development time ## YOUR TASK: Create a comprehensive implementation plan for Phase 1 that: 1. Breaks the specification into actionable tasks 2. Follows checkpoint-driven development pattern 3. Creates ADRs for architectural decisions 4. Sets up testing from the beginning 5. Prepares for Phase 2 integration ## OUTPUT REQUIREMENTS: File Location: specs/00-1 Project Foundation Setup/plan.md Plan Structure: ```markdown # Phase 1: Project Foundation Setup - Implementation Plan ## 1. Architecture Overview [Text-based architecture diagram showing frontend-backend-database relationships] ## 2. Implementation Strategy - Checkpoint-driven development approach - TDD (Test-Driven Development) where applicable - Constitution compliance verification at each step ## 3. Phase Breakdown ### Phase 1A: Monorepo & Git Foundation (Day 1) Goal: Create project structure and version control Tasks: 1. [ ] Create project root directory ADD_TaskFlow-App/ 2. [ ] Create folder structure per constitution and spec 3. [ ] Initialize Git repository with .gitignore 4. [ ] Create initial README.md with project overview 5. [ ] Create CLAUDE.md files (root, frontend, backend) 6. [ ] Set up Git hooks (pre-commit for linting) Deliverables: - Complete folder structure - Git repository with initial commit - Documentation foundation ### Phase 1B: Frontend Foundation (Next.js 16) (Day 1-2) Goal: Set up Next.js 16 with TypeScript and App Router Tasks: 1. [ ] Initialize Next.js 16 with TypeScript and App Router - Command: npx create-next-app@latest frontend --typescript --tailwind --app --no-eslint - Verify TypeScript strict mode enabled 2. [ ] Configure Tailwind CSS with design tokens - Update tailwind.config.ts with constitution colors - Add Inter font from Google Fonts 3. [ ] Install and configure additional dependencies - framer-motion for animations - date-fns for date manipulation - clsx for conditional classes 4. [ ] Set up ESLint + Prettier with project rules 5. [ ] Create basic layout structure: - app/layout.tsx with metadata and providers - app/page.tsx landing page showing project status - app/globals.css with Tailwind directives 6. [ ] Configure next.config.js for environment variables 7. [ ] Create lib/api.ts skeleton for API client Testing Setup: - [ ] Install Jest + React Testing Library - [ ] Configure test environment - [ ] Write basic test for landing page ### Phase 1C: Backend Foundation (FastAPI) (Day 2) Goal: Set up FastAPI server with database connection Tasks: 1. [ ] Create Python virtual environment 2. [ ] Create requirements.txt with pinned versions: fastapi==0.104.1 uvicorn[standard]==0.24.0 sqlmodel==0.0.14 psycopg2-binary==2.9.9 python-jose[cryptography]==3.3.0 passlib[bcrypt]==1.7.4 pydantic-settings==2.1.0 pytest==7.4.3 3. [ ] Create FastAPI application structure: - src/main.py: FastAPI app with middleware - src/config.py: Configuration from environment - src/database.py: SQLModel engine and session - src/api/v1/health.py: Health endpoints - src/core/middleware.py: CORS middleware 4. [ ] Set up environment variables (.env, .env.example): - DATABASE_URL: Neon PostgreSQL connection - JWT_SECRET: Random secret (Phase 2 preparation) - ALLOWED_ORIGINS: http://localhost:3000 5. [ ] Configure CORS for frontend communication 6. [ ] Create OpenAPI/Swagger documentation at /docs Testing Setup: - [ ] Install pytest and configure - [ ] Create test for health endpoint - [ ] Test database connection ### Phase 1D: Design System Implementation (Day 2-3) Goal: Implement complete design system with UI components Tasks: 1. [ ] Complete Tailwind configuration: - Color palette (primary gradient, secondary, semantic colors) - Typography scale (12px to 32px) - Spacing system (4px baseline) 2. [ ] Create 6 UI components in frontend/components/ui/: - Button.tsx: Primary, Secondary, Ghost variants - Card.tsx: Glassmorphism effect with shadow - Input.tsx: With label, error state, validation - Modal.tsx: Dialog with overlay and animations - LoadingSpinner.tsx: Animated spinner - Toast.tsx: Notification component (Phase 2-4 ready) 3. [ ] Create animation utilities with Framer Motion: - Fade in/out animations - Slide transitions - Scale effects 4. [ ] Create design system documentation: - docs/design-system.md - Component usage examples - Animation guidelines Testing: - [ ] Unit tests for all UI components - [ ] Visual regression testing setup ### Phase 1E: Integration & Validation (Day 3-4) Goal: Connect all components and validate against acceptance criteria Tasks: 1. [ ] Connect frontend to backend API - Update API client to use NEXT_PUBLIC_API_URL - Test CORS configuration 2. [ ] Set up Neon PostgreSQL connection - Create database and get connection string - Test connection with simple query 3. [ ] Create comprehensive health check system: - Backend: GET /api/v1/health with database status - Frontend: Health status display on landing page 4. [ ] Validate all 21 acceptance criteria: - Frontend: 7 criteria (Next.js, TypeScript, Tailwind, etc.) - Backend: 6 criteria (FastAPI, health endpoint, database, etc.) - Development: 5 criteria (monorepo, Git, cross-platform, etc.) - Design System: 5 criteria (colors, typography, spacing, etc.) 5. [ ] Create complete documentation: - README.md with setup instructions - docs/setup.md detailed guide - API documentation via Swagger UI - Troubleshooting guide ## 4. Architectural Decision Records (ADRs) Create ADRs for these decisions: ### ADR 001: Monorepo Structure - Context: Need coordinated frontend-backend development - Decision: Single repository with frontend/ and backend/ folders - Consequences: Simplified dependency management, single CI/CD pipeline - Alternatives Considered: Separate repos, Nx workspace ### ADR 002: Next.js App Router Choice - Context: Next.js offers Pages Router (stable) vs App Router (modern) - Decision: App Router for better performance, layouts, and React 18 features - Consequences: Learning curve, but future-proof architecture - Alternatives Considered: Pages Router, Remix, SvelteKit ### ADR 003: SQLModel ORM Selection - Context: Need type-safe database operations in Python - Decision: SQLModel (SQLAlchemy + Pydantic) - Consequences: Single source of truth for models, but newer library - Alternatives Considered: SQLAlchemy + Pydantic separately, Django ORM ## 5. Dependency Graph Phase 1A (Monorepo) ↓ Phase 1B (Frontend) ← Independent → Phase 1C (Backend) ↓ ↓ Phase 1D (Design System) ↓ Phase 1E (Integration) Parallel Work: Frontend (1B) and Backend (1C) can proceed simultaneously after Phase 1A. ## 6. Testing Strategy ### Frontend Testing: - Unit Tests: Jest + React Testing Library for components - Integration Tests: API mocking with MSW - Visual Tests: Storybook (optional for Phase 1) - Coverage Goal: 80% (constitution requirement) ### Backend Testing: - Unit Tests: pytest for business logic - API Tests: FastAPI TestClient for endpoints - Database Tests: Test with SQLite in memory - Coverage Goal: 90% (constitution requirement) ### Test Pyramid: E2E Tests (Phase 4) / \ Integration Tests Integration Tests / Unit Tests (Frontend) Unit Tests (Backend) ## 7. Risk Mitigation Plan | Risk | Probability | Impact | Mitigation | |------|-------------|--------|------------| | Database connection fails | Medium | High | Use SQLite for development, fallback connection | | CORS configuration issues | Medium | Medium | Test early, use permissive CORS in development | | TypeScript strict errors | High | Low | Incremental adoption, any only where necessary | | Dependency version conflicts | Low | Medium | Pin exact versions, use lock files | | Design system inconsistencies | Medium | Medium | CSS variables for single source of truth | ## 8. Success Validation ### Validation Checklist: - [ ] **Frontend Running:** cd frontend && npm run dev → http://localhost:3000 - [ ] **Backend Running:** cd backend && uvicorn src.main:app --reload → http://localhost:8000 - [ ] **Health Endpoint:** GET /api/v1/health returns 200 OK - [ ] **Database Connected:** Can query PostgreSQL database - [ ] **CORS Working:** Frontend can call backend API - [ ] **Design System:** All 6 UI components render correctly - [ ] **Animations:** Framer Motion animations work smoothly - [ ] **TypeScript:** No errors in frontend or backend - [ ] **Testing:** Frontend 80%+, Backend 90%+ coverage - [ ] **Documentation:** README and setup guides complete ### Performance Metrics: - Frontend Lighthouse score > 90 - Backend health endpoint < 100ms response - No console errors in development ## 9. Timeline & Estimation **Day-by-Day Breakdown:** **Day 1 (8 hours):** - Phase 1A: Monorepo & Git (2 hours) - Phase 1B: Frontend Foundation (6 hours) **Day 2 (6 hours):** - Phase 1C: Backend Foundation (4 hours) - Phase 1D: Design System start (2 hours) **Day 3 (6 hours):** - Phase 1D: Design System completion (4 hours) - Phase 1E: Integration start (2 hours) **Day 4 (4 hours):** - Phase 1E: Integration completion (3 hours) - Final validation and documentation (1 hour) **Day 5 (4 hours buffer):** - Issue fixing and refinements - Preparation for Phase 2 **Total Estimated: 28 hours** ## 10. Phase 2 Preparation - Database schema ready for users table - JWT secret configured in environment - API client structure in place - Authentication components stubbed - Health monitoring for Phase 2 features --- **Created:** [Current Date] **Version:** 1.0 **Status:** Ready for Implementation **Conforms to:** ADD_TaskFlow-App Constitution v1.0
labels: ["plan", "phase-1", "foundation-setup"]
links:
  spec: specs/P2-1-foundation-setup/spec.md
  ticket: null
  adr: null
  pr: null
files:
- specs/P2-1-foundation-setup/plan.md
tests:

---

## Prompt

5. [ ] Configure CORS for frontend communication 6. [ ] Create OpenAPI/Swagger documentation at /docs Testing Setup: - [ ] Install pytest and configure - [ ] Create test for health endpoint - [ ] Test database connection ### Phase 1D: Design System Implementation (Day 2-3) Goal: Implement complete design system with UI components Tasks: 1. [ ] Complete Tailwind configuration: - Color palette (primary gradient, secondary, semantic colors) - Typography scale (12px to 32px) - Spacing system (4px baseline) 2. [ ] Create 6 UI components in frontend/components/ui/: - Button.tsx: Primary, Secondary, Ghost variants - Card.tsx: Glassmorphism effect with shadow - Input.tsx: With label, error state, validation - Modal.tsx: Dialog with overlay and animations - LoadingSpinner.tsx: Animated spinner - Toast.tsx: Notification component (Phase 2-4 ready) 3. [ ] Create animation utilities with Framer Motion: - Fade in/out animations - Slide transitions - Scale effects 4. [ ] Create design system documentation: - docs/design-system.md - Component usage examples - Animation guidelines Testing: - [ ] Unit tests for all UI components - [ ] Visual regression testing setup ### Phase 1E: Integration & Validation (Day 3-4) Goal: Connect all components and validate against acceptance criteria Tasks: 1. [ ] Connect frontend to backend API - Update API client to use NEXT_PUBLIC_API_URL - Test CORS configuration 2. [ ] Set up Neon PostgreSQL connection - Create database and get connection string - Test connection with simple query 3. [ ] Create comprehensive health check system: - Backend: GET /api/v1/health with database status - Frontend: Health status display on landing page 4. [ ] Validate all 21 acceptance criteria: - Frontend: 7 criteria (Next.js, TypeScript, Tailwind, etc.) - Backend: 6 criteria (FastAPI, health endpoint, database, etc.) - Development: 5 criteria (monorepo, Git, cross-platform, etc.) - Design System: 5 criteria (colors, typography, spacing, etc.) 5. [ ] Create complete documentation: - README.md with setup instructions - docs/setup.md detailed guide - API documentation via Swagger UI - Troubleshooting guide ## 4. Architectural Decision Records (ADRs) Create ADRs for these decisions: ### ADR 001: Monorepo Structure - Context: Need coordinated frontend-backend development - Decision: Single repository with frontend/ and backend/ folders - Consequences: Simplified dependency management, single CI/CD pipeline - Alternatives Considered: Separate repos, Nx workspace ### ADR 002: Next.js App Router Choice - Context: Next.js offers Pages Router (stable) vs App Router (modern) - Decision: App Router for better performance, layouts, and React 18 features - Consequences: Learning curve, but future-proof architecture - Alternatives Considered: Pages Router, Remix, SvelteKit ### ADR 003: SQLModel ORM Selection - Context: Need type-safe database operations in Python - Decision: SQLModel (SQLAlchemy + Pydantic) - Consequences: Single source of truth for models, but newer library - Alternatives Considered: SQLAlchemy + Pydantic separately, Django ORM ## 5. Dependency Graph Phase 1A (Monorepo) ↓ Phase 1B (Frontend) ← Independent → Phase 1C (Backend) ↓ ↓ Phase 1D (Design System) ↓ Phase 1E (Integration) Parallel Work: Frontend (1B) and Backend (1C) can proceed simultaneously after Phase 1A. ## 6. Testing Strategy ### Frontend Testing: - Unit Tests: Jest + React Testing Library for components - Integration Tests: API mocking with MSW - Visual Tests: Storybook (optional for Phase 1) - Coverage Goal: 80% (constitution requirement) ### Backend Testing: - Unit Tests: pytest for business logic - API Tests: FastAPI TestClient for endpoints - Database Tests: Test with SQLite in memory - Coverage Goal: 90% (constitution requirement) ### Test Pyramid: E2E Tests (Phase 4) / \ Integration Tests Integration Tests / Unit

5. [ ] Configure CORS for frontend communication 6. [ ] Create OpenAPI/Swagger documentation at /docs Testing Setup: - [ ] Install pytest and configure - [ ] Create test for health endpoint - [ ] Test database connection ### Phase 1D: Design System Implementation (Day 2-3) Goal: Implement complete design system with UI components Tasks: 1. [ ] Complete Tailwind configuration: - Color palette (primary gradient, secondary, semantic colors) - Typography scale (12px to 32px) - Spacing system (4px baseline) 2. [ ] Create 6 UI components in frontend/components/ui/: - Button.tsx: Primary, Secondary, Ghost variants - Card.tsx: Glassmorphism effect with shadow - Input.tsx: With label, error state, validation - Modal.tsx: Dialog with overlay and animations - LoadingSpinner.tsx: Animated spinner - Toast.tsx: Notification component (Phase 2-4 ready) 3. [ ] Create animation utilities with Framer Motion: - Fade in/out animations - Slide transitions - Scale effects 4. [ ] Create design system documentation: - docs/design-system.md - Component usage examples - Animation guidelines Testing: - [ ] Unit tests for all UI components - [ ] Visual regression testing setup ### Phase 1E: Integration & Validation (Day 3-4) Goal: Connect all components and validate against acceptance criteria Tasks: 1. [ ] Connect frontend to backend API - Update API client to use NEXT_PUBLIC_API_URL - Test CORS configuration 2. [ ] Set up Neon PostgreSQL connection - Create database and get connection string - Test connection with simple query 3. [ ] Create comprehe